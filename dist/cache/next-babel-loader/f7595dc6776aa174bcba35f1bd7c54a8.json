{"ast":null,"code":"import _JSXStyle from \"styled-jsx/style\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport { connect } from \"react-redux\";\nimport { __GET_ACTIVE_USERS_MESSAGES, __ADD_MESSAGE, __GET_CHAT_USERS, __IS_TYPING_TO_ACTIVE_USER, __EDIT_MESSAGE } from 'store/saga';\nimport { __SET_ENCRYPT_DATA } from 'store/actions';\nimport TextAreaMessage from 'components/elements/TextAreaMessage';\nimport Skeleton from \"./Skeleton\";\nimport PrivateMessageContent from \"components/elements/PrivateMessageContent\";\nimport { Modal } from 'components/shared/UI/Modal';\nimport UI_ELEMENTS from \"./shared/UI\";\nimport { Bus } from \"components/shared/helpers/Bus\";\nimport { Vigenere, RSA, Caesar, Playfair, Vernam, Substitution } from 'libraries';\n\nclass Messages extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      startMessageNotify: '',\n      skeletonLoading: true,\n      noChatUser: false,\n      activeUserData: {},\n      showModal: false,\n      beforeClose: false,\n      sendMessage: '',\n      modalData: {\n        yourMessage: '',\n        encryptText: '',\n        warningMsg: ''\n      }\n    };\n    this.__sendMessage = this.__sendMessage.bind(this);\n    this.__isTyping = this.__isTyping.bind(this);\n    this.__handleSuccess = this.__handleSuccess.bind(this);\n    this.__closeModal = this.__closeModal.bind(this);\n    this.__handleSubmitMessage = this.__handleSubmitMessage.bind(this);\n    this.__updateStateContent = this.__updateStateContent.bind(this);\n    this.__messagesHaveBeenDeleted = this.__messagesHaveBeenDeleted.bind(this);\n  }\n\n  async componentDidUpdate(prevProps, prevState, snapshot) {\n    var _prevProps$activeUser, _this$props$activeUse, _prevProps$activeUser2, _this$props$activeUse2, _prevProps$activeUser3, _this$props$activeUse4, _this$props$activeUse5;\n\n    // Working when my chat list is empty\n    if (!this.state.noChatUser && this.props.usersList && this.props.usersList.length === 0) {\n      this.setState({\n        noChatUser: true\n      });\n    } else if (this.state.noChatUser && this.props.usersList && this.props.usersList.length !== 0) {\n      this.setState({\n        noChatUser: false\n      });\n    }\n\n    if (!((_prevProps$activeUser = prevProps.activeUser) === null || _prevProps$activeUser === void 0 ? void 0 : _prevProps$activeUser.id) && ((_this$props$activeUse = this.props.activeUser) === null || _this$props$activeUse === void 0 ? void 0 : _this$props$activeUse.id) && ((_prevProps$activeUser2 = prevProps.activeUser) === null || _prevProps$activeUser2 === void 0 ? void 0 : _prevProps$activeUser2.id) !== ((_this$props$activeUse2 = this.props.activeUser) === null || _this$props$activeUse2 === void 0 ? void 0 : _this$props$activeUse2.id)) {\n      var _this$props$activeUse3;\n\n      this.setState({\n        startMessageNotify: '',\n        skeletonLoading: true\n      });\n      const startTime = new Date().getTime();\n      const genMessages = await __GET_ACTIVE_USERS_MESSAGES((_this$props$activeUse3 = this.props.activeUser) === null || _this$props$activeUse3 === void 0 ? void 0 : _this$props$activeUse3.id).next();\n      const endTime = new Date().getTime();\n\n      this.__updateStateContent(genMessages.value.letters[0].message, endTime, startTime);\n    } else if (((_prevProps$activeUser3 = prevProps.activeUser) === null || _prevProps$activeUser3 === void 0 ? void 0 : _prevProps$activeUser3.id) !== ((_this$props$activeUse4 = this.props.activeUser) === null || _this$props$activeUse4 === void 0 ? void 0 : _this$props$activeUse4.id) && ((_this$props$activeUse5 = this.props.activeUser) === null || _this$props$activeUse5 === void 0 ? void 0 : _this$props$activeUse5.id)) {\n      var _this$props$activeUse6;\n\n      this.setState({\n        startMessageNotify: '',\n        skeletonLoading: true\n      });\n      const startTime = new Date().getTime();\n      const genMessages = await __GET_ACTIVE_USERS_MESSAGES((_this$props$activeUse6 = this.props.activeUser) === null || _this$props$activeUse6 === void 0 ? void 0 : _this$props$activeUse6.id).next();\n      const endTime = new Date().getTime();\n\n      this.__updateStateContent(genMessages.value.letters[0].message, endTime, startTime);\n    } else if (prevProps.messages.length === 1 && prevProps.messages[0].message === '' && this.props.messages.length === 1 && this.props.messages[0].message !== '') {\n      this.setState({\n        startMessageNotify: ''\n      });\n    }\n  }\n\n  __messagesHaveBeenDeleted() {\n    this.setState({\n      startMessageNotify: 'Send the first letter'\n    });\n  }\n\n  __updateStateContent(message, endTime, startTime) {\n    this.setState(_objectSpread({}, message === '' && {\n      startMessageNotify: 'Send the first letter'\n    }));\n\n    if (endTime - startTime < 1000) {\n      setTimeout(() => {\n        this.setState({\n          noChatUser: false,\n          skeletonLoading: false\n        });\n      }, 1000);\n    } else {\n      this.setState({\n        noChatUser: false,\n        skeletonLoading: false\n      });\n    }\n  }\n\n  __isTyping(hint) {\n    var _this$props$activeUse7;\n\n    __IS_TYPING_TO_ACTIVE_USER(hint, (_this$props$activeUse7 = this.props.activeUser) === null || _this$props$activeUse7 === void 0 ? void 0 : _this$props$activeUse7.id, this.props.loggedUser.id).next();\n  }\n\n  __handleSuccess() {\n    this.setState({\n      beforeClose: true\n    });\n  }\n\n  __closeModal() {\n    this.setState({\n      beforeClose: false,\n      showModal: false\n    }, () => {\n      if (this.state.modalData.encryptText) this.__handleSubmitMessage(this.state.sendMessage, this.state.modalData.encryptText, this.state.modalData.decryptText);\n    });\n  }\n\n  async __handleSubmitMessage(value, encryptedMsg, decryptMsg) {\n    var _this$props$encryptDa, _this$props$activeUse8, _this$props$activeUse9;\n\n    const isKey = value === 'crypt' && value === encryptedMsg && value === decryptMsg && isNaN(decryptMsg);\n    const messageData = {\n      time: new Date().getTime(),\n      message: value,\n      encryptedMsg: encryptedMsg,\n      decryptedMsg: decryptMsg,\n      key: isKey ? 'crypt' : (_this$props$encryptDa = this.props.encryptData) === null || _this$props$encryptDa === void 0 ? void 0 : _this$props$encryptDa.key,\n      encryptType: isKey ? 'crypt' : this.props.encryptData.type\n    };\n    await __ADD_MESSAGE({\n      friend: {\n        friendId: (_this$props$activeUse8 = this.props.activeUser) === null || _this$props$activeUse8 === void 0 ? void 0 : _this$props$activeUse8.id,\n        loggedUser: this.props.loggedUser,\n        msgData: _objectSpread({}, messageData, {\n          owner: this.props.loggedUser.id\n        })\n      },\n      my: {\n        friendId: (_this$props$activeUse9 = this.props.activeUser) === null || _this$props$activeUse9 === void 0 ? void 0 : _this$props$activeUse9.id,\n        loggedUser: this.props.loggedUser,\n        msgData: _objectSpread({}, messageData, {\n          owner: 'Me'\n        })\n      }\n    }).next();\n\n    __GET_CHAT_USERS().next();\n\n    this.setState({\n      startMessageNotify: ''\n    });\n    Bus.dispatch('messageSendingFinish');\n  }\n\n  __encryptCommon(value, key, type, callback = () => {}) {\n    let sendMSG = {};\n\n    switch (type) {\n      case 'vigenere':\n        const encryptedMsgV = Vigenere.doCryptVigenere(false, value, key, msg => {\n          callback(msg);\n\n          this.props.__SET_ENCRYPT_DATA({\n            type: 'warning',\n            value: true\n          });\n        });\n        return sendMSG = {\n          encryptedMSG: encryptedMsgV,\n          decryptedMSG: Vigenere.doCryptVigenere(true, encryptedMsgV, key, msg => {\n            callback(msg);\n\n            this.props.__SET_ENCRYPT_DATA({\n              type: 'warning',\n              value: true\n            });\n          })\n        };\n\n      case 'substitution':\n        const encryptedMsgS = Substitution(value);\n        return sendMSG = {\n          encryptedMSG: encryptedMsgS.encrypt,\n          decryptedMSG: encryptedMsgS.decrypt\n        };\n\n      case 'rsa':\n        // Message\n        const message = value; // Generate RSA keys\n\n        const keys = RSA.generate(key);\n        const encoded_message = RSA.encode(message);\n        const encrypted_message = RSA.encrypt(encoded_message, keys.n, keys.e);\n        const decrypted_message = RSA.decrypt(encrypted_message, keys.d, keys.n);\n        const decoded_message = RSA.decode(decrypted_message);\n        return sendMSG = {\n          encryptedMSG: encoded_message.toString(),\n          decryptedMSG: decoded_message\n        };\n\n      case 'caesar':\n        const encryptedMsgC = Caesar.doCrypt(false, value, key, msg => {\n          callback(msg);\n        });\n        return sendMSG = {\n          encryptedMSG: encryptedMsgC,\n          decryptedMSG: Caesar.doCrypt(true, encryptedMsgC, key, msg => {\n            callback(msg);\n          })\n        };\n\n      case 'playfair':\n        return sendMSG = {\n          encryptedMSG: Playfair.doCipher(value, key, msg => {\n            callback(msg);\n          }),\n          decryptedMSG: Playfair.deCodeCipher(value, key)\n        };\n\n      case 'vernam':\n        let _keyE = '';\n        const encryptedMsgVer = Vernam.doEncrypt(value, _key => {\n          _keyE = _key;\n\n          this.props.__SET_ENCRYPT_DATA({\n            type: 'key',\n            value: _key\n          });\n        });\n        return sendMSG = {\n          encryptedMSG: encryptedMsgVer,\n          decryptedMSG: Vernam.doDecrypt(value, _keyE)\n        };\n\n      default:\n        break;\n    }\n  }\n\n  async __sendMessage(value, isKey) {\n    if (isKey instanceof Object) {\n      var _isKey$mainObj, _isKey$mainObj2, _this$props$activeUse10, _this$props$loggedUse;\n\n      const encryptedMsg = this.__encryptCommon.call(this, value, (_isKey$mainObj = isKey.mainObj) === null || _isKey$mainObj === void 0 ? void 0 : _isKey$mainObj.key, (_isKey$mainObj2 = isKey.mainObj) === null || _isKey$mainObj2 === void 0 ? void 0 : _isKey$mainObj2.encryptType);\n\n      await __EDIT_MESSAGE({\n        value,\n        e: encryptedMsg.encryptedMSG,\n        d: encryptedMsg.decryptedMSG\n      }, isKey === null || isKey === void 0 ? void 0 : isKey.index, {\n        idUser: (_this$props$activeUse10 = this.props.activeUser) === null || _this$props$activeUse10 === void 0 ? void 0 : _this$props$activeUse10.id,\n        myId: (_this$props$loggedUse = this.props.loggedUser) === null || _this$props$loggedUse === void 0 ? void 0 : _this$props$loggedUse.id\n      }).next();\n      Bus.dispatch('endEditing');\n      Bus.dispatch('messageSendingFinish');\n      return;\n    } else if (isKey) {\n      this.__handleSubmitMessage('crypt', 'crypt', 'crypt');\n\n      return;\n    }\n\n    let warning = '';\n    this.setState({\n      sendMessage: value\n    }, () => {\n      var _this$props$encryptDa2;\n\n      const encryptMsg = this.__encryptCommon.call(this, value, (_this$props$encryptDa2 = this.props.encryptData) === null || _this$props$encryptDa2 === void 0 ? void 0 : _this$props$encryptDa2.key, this.props.encryptData.type, msg => {\n        warning = msg;\n      });\n\n      if (this.props.isShowModal) {\n        this.setState({\n          modalData: _objectSpread({\n            yourMessage: value\n          }, warning && {\n            warningMsg: warning\n          }, {}, encryptMsg.encryptedMSG && {\n            encryptText: encryptMsg.encryptedMSG\n          }, {}, encryptMsg.decryptedMSG && {\n            decryptText: encryptMsg.decryptedMSG\n          }),\n          showModal: true\n        });\n      } else if (encryptMsg.encryptedMSG && encryptMsg.decryptedMSG) this.__handleSubmitMessage(value, encryptMsg.encryptedMSG, encryptMsg.decryptedMSG);\n    });\n  }\n\n  render() {\n    var _this$props$loggedUse2;\n\n    return __jsx(\"div\", {\n      className: \"jsx-610849184\" + \" \" + `message-content-right \n                ${this.state.skeletonLoading ? 'skeleton-loading-content' : ''} \n                ${!this.state.noChatUser ? 'hidden-overlay' : ''} \n                ${this.state.startMessageNotify ? 'empty-message-content' : ''}\n                ${this.state.noChatUser ? 'no-chat-user' : ''}\n                `\n    }, this.state.skeletonLoading && !this.state.noChatUser ? new Array(6).fill('').map((_, i) => {\n      return __jsx(\"div\", {\n        key: i + Math.random().toString(16).slice(2, 6),\n        style: {\n          opacity: (6 - i) * 0.10\n        },\n        className: \"jsx-610849184\" + \" \" + `skeleton-container-messages ${i % 2 !== 0 ? 'odd-container-skeleton' : ''}`\n      }, __jsx(Skeleton, {\n        width: \"35px\",\n        height: \"35px\",\n        margin: ['5px', '10px', '0px', '10px'],\n        radius: \"50%\"\n      }), __jsx(\"div\", {\n        className: \"jsx-610849184\" + \" \" + \"line-wrap\"\n      }, __jsx(Skeleton, {\n        width: \"55%\",\n        height: \"52px\",\n        margin: ['5px', '0px', '0px', i % 2 !== 0 ? 'auto' : '0px'],\n        radius: \"0%\"\n      }), i % 2 !== 0 ? __jsx(Skeleton, {\n        width: \"55%\",\n        height: \"52px\",\n        margin: ['5px', '0px', '0px', 'auto'],\n        radius: \"0%\"\n      }) : ''));\n    }) : this.state.startMessageNotify ? __jsx(\"div\", {\n      className: \"jsx-610849184\" + \" \" + \"send-first-message\"\n    }, this.state.startMessageNotify) : !this.state.noChatUser && __jsx(PrivateMessageContent, {\n      messagesHaveBeenDeleted: this.__messagesHaveBeenDeleted\n    }), !this.state.skeletonLoading && __jsx(TextAreaMessage, {\n      activeUser: this.props.activeUser,\n      loggedUserId: (_this$props$loggedUse2 = this.props.loggedUser) === null || _this$props$loggedUse2 === void 0 ? void 0 : _this$props$loggedUse2.id,\n      isTyping: this.__isTyping,\n      sendMessage: this.__sendMessage\n    }), __jsx(Modal, {\n      show: this.state.showModal,\n      beforeClose: this.state.beforeClose,\n      close: this.__closeModal\n    }, __jsx(\"div\", {\n      className: \"jsx-610849184\" + \" \" + \"scroll-content\"\n    }, __jsx(\"h2\", {\n      className: \"jsx-610849184\"\n    }, \"Please confirm message\"), __jsx(\"h4\", {\n      className: \"jsx-610849184\"\n    }, \"Your included text\"), __jsx(\"p\", {\n      className: \"jsx-610849184\" + \" \" + \"message-p\"\n    }, this.state.modalData.yourMessage), __jsx(\"h4\", {\n      className: \"jsx-610849184\"\n    }, \"Encrypted text\"), this.state.modalData.warningMsg ? __jsx(\"p\", {\n      className: \"jsx-610849184\" + \" \" + \"warning-message\"\n    }, this.state.modalData.warningMsg) : __jsx(\"p\", {\n      className: \"jsx-610849184\" + \" \" + \"message-p\"\n    }, this.state.modalData.encryptText)), __jsx(UI_ELEMENTS.Button, {\n      background: \"#37415c\",\n      color: \"#fff\",\n      fontSize: 11,\n      type: \"button\",\n      text: 'Send',\n      width: 100,\n      margin: ['20px', '0', '0', 'auto'],\n      onClick: this.__handleSuccess,\n      size: \"sm\"\n    })), __jsx(_JSXStyle, {\n      id: \"610849184\"\n    }, [\".scroll-content.jsx-610849184{max-height:70vh;overflow-x:hidden;}\", \".message-p.jsx-610849184{word-break:break-all;}\", \".warning-message.jsx-610849184{color:#ffa100;}\", \".skeleton-container-messages.jsx-610849184 .line-wrap.jsx-610849184{width:calc(100% - 70px);margin-bottom:10px;}\", \".odd-container-skeleton.jsx-610849184{-webkit-flex-direction:row-reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse;}\", \".skeleton-container-messages.jsx-610849184{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}\", \".message-content-right.hidden-overlay.jsx-610849184{overflow:hidden;}\", \".message-content-right.skeleton-loading-content.jsx-610849184{overflow:hidden;-webkit-box-pack:start;-webkit-justify-content:flex-start;-ms-flex-pack:start;justify-content:flex-start;}\", \".message-content-right.jsx-610849184{height:calc(100% - 42px);display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}\", \".empty-message-content.jsx-610849184{-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end;}\", \".send-first-message.jsx-610849184{text-align:center;font-size:20px;margin-bottom:16px;}\", \".no-chat-user.jsx-610849184{background-image:url('./assets/images/nochat.png');background-position:center;background-repeat:no-repeat;opacity:.2;}\"]));\n  }\n\n}\n\nconst mapStateToProps = state => ({\n  loggedUser: state.chat.loggedUser,\n  activeUser: state.chat.activeUser,\n  usersList: state.chat.myChatUsers,\n  isShowModal: state.chat.isShowModal,\n  encryptData: state.chat.encryptData,\n  messages: state.chat.activeUserMessages\n});\n\nconst mapDispatchToProps = {\n  __SET_ENCRYPT_DATA\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Messages);","map":null,"metadata":{},"sourceType":"module"}