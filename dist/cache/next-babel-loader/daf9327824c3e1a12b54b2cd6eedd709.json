{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport default class Playfair {\n  // static isChet = false;\n  // static flag = false;\n  static deCodeCipher(msg, key) {\n    let text = '';\n    let text1 = this.doCipher(msg, key);\n    let keyResult = this.processKey(key);\n\n    for (let i = 0; i < text1.length; i += 2) {\n      let pair1 = text1[i];\n      let pair2 = text1[i + 1];\n      let p1i, p1j, p2i, p2j;\n\n      for (let stroke = 0; stroke < keyResult.length; stroke++) {\n        for (let stolbec = 0; stolbec < keyResult[stroke].length; stolbec++) {\n          if (keyResult[stroke][stolbec] === pair1) {\n            p1i = stroke;\n            p1j = stolbec;\n          }\n\n          if (keyResult[stroke][stolbec] === pair2) {\n            p2i = stroke;\n            p2j = stolbec;\n          }\n        }\n      }\n\n      let coord1 = '',\n          coord2 = '';\n\n      if (p1i === p2i) {\n        if (p1j === 0) {\n          coord1 = keyResult[p1i][4];\n        } else {\n          coord1 = keyResult[p1i][p1j - 1];\n        }\n\n        if (p2j === 0) {\n          coord2 = keyResult[p2i][4];\n        } else {\n          coord2 = keyResult[p2i][p2j - 1];\n        }\n      }\n\n      if (p1j === p2j) {\n        if (p1i === 0) {\n          coord1 = keyResult[4][p1j];\n        } else {\n          coord1 = keyResult[p1i - 1][p1j];\n        }\n\n        if (p2i === 0) {\n          coord2 = keyResult[4][p2j];\n        } else {\n          coord2 = keyResult[p2i - 1][p2j];\n        }\n      }\n\n      if (p1i !== p2i && p1j !== p2j) {\n        coord1 = keyResult[p1i][p2j];\n        coord2 = keyResult[p2i][p1j];\n      }\n\n      text = text + coord1 + coord2;\n    }\n\n    text = text.split('');\n\n    for (let i = 0; i < text.length; i++) {\n      let count;\n\n      if (this.flagAdd) {\n        if (text[i] === text[i + 2] && (text[i + 1] === 'X' || text[i + 1] === 'Q')) {\n          count = i + 1;\n          text.splice(count, 1);\n        }\n      } else if (this.flagAdd && this.isEnd && (this.flagX || !this.flagX)) {\n        if (text[i - 2] === text[i] && (text[i - 1] === 'X' || text[i - 1] === 'Q')) count = i + 1;\n        text.splice(count, 1);\n      } else if (!this.flagAdd) {\n        break;\n      }\n    }\n\n    if (this.flagX) {\n      text.pop();\n    }\n\n    if (this.isEnd && !this.flagX) {\n      text.pop();\n    }\n\n    text = text.join('');\n    return text;\n  }\n\n  static processKey(key) {\n    let _key = key;\n    _key = _key.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\n    let temp = '';\n    let alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ';\n\n    for (let i = 0; i < _key.length; i++) {\n      if (alphabet.indexOf(_key[i]) !== -1) {\n        alphabet = alphabet.replace(_key[i], '');\n        temp += _key[i];\n      }\n    }\n\n    temp += alphabet;\n    const result = [];\n    temp = temp.split('');\n\n    while (temp[0]) {\n      result.push(temp.splice(0, 5));\n    }\n\n    return result;\n  }\n\n}\n\n_defineProperty(Playfair, \"flagX\", false);\n\n_defineProperty(Playfair, \"flagAdd\", false);\n\n_defineProperty(Playfair, \"isEnd\", false);\n\n_defineProperty(Playfair, \"doCipher\", (msg, key, callback) => {\n  let keyResult = Playfair.processKey(key);\n  let error = 'Warning!!! String is empty';\n  let textPhrase, separator;\n  msg = msg.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\n\n  if (msg.length === 0) {\n    callback(error);\n    return;\n  } else {\n    textPhrase = msg[0];\n  }\n\n  let help = 0;\n\n  for (let i = 1; i < msg.length; i++) {\n    if (msg[i - 1] === msg[i]) {\n      if (msg[i] === 'X') {\n        separator = 'Q';\n      } else {\n        separator = 'X';\n      }\n\n      textPhrase += separator + msg[i];\n      help = 1;\n    } else {\n      textPhrase += msg[i];\n    }\n\n    if (help === 1) {\n      Playfair.flagAdd = true;\n    }\n  }\n\n  if (textPhrase.length % 2 !== 0) {\n    if (textPhrase[textPhrase.length - 1] === 'X') {\n      textPhrase += 'Q';\n      Playfair.isEnd = true;\n      Playfair.flagX = false;\n    } else {\n      textPhrase += 'X';\n      Playfair.isEnd = true;\n      Playfair.flagX = true;\n    }\n  }\n\n  let enCodeStr = '';\n\n  for (let i = 0; i < textPhrase.length; i += 2) {\n    let pair1 = textPhrase[i];\n    let pair2 = textPhrase[i + 1];\n    let p1i, p1j, p2i, p2j;\n\n    for (let stroke = 0; stroke < keyResult.length; stroke++) {\n      for (let stolbec = 0; stolbec < keyResult[stroke].length; stolbec++) {\n        if (keyResult[stroke][stolbec] === pair1) {\n          p1i = stroke;\n          p1j = stolbec;\n        }\n\n        if (keyResult[stroke][stolbec] === pair2) {\n          p2i = stroke;\n          p2j = stolbec;\n        }\n      }\n    }\n\n    let coord1 = '',\n        coord2 = '';\n\n    if (p1i === p2i) {\n      if (p1j === 4) {\n        coord1 = keyResult[p1i][0];\n      } else {\n        coord1 = keyResult[p1i][p1j + 1];\n      }\n\n      if (p2j === 4) {\n        coord2 = keyResult[p2i][0];\n      } else {\n        coord2 = keyResult[p2i][p2j + 1];\n      }\n    }\n\n    if (p1j === p2j) {\n      if (p1i === 4) {\n        coord1 = keyResult[0][p1j];\n      } else {\n        coord1 = keyResult[p1i + 1][p1j];\n      }\n\n      if (p2i === 4) {\n        coord2 = keyResult[0][p2j];\n      } else {\n        coord2 = keyResult[p2i + 1][p2j];\n      }\n    }\n\n    if (p1i !== p2i && p1j !== p2j) {\n      coord1 = keyResult[p1i][p2j];\n      coord2 = keyResult[p2i][p1j];\n    }\n\n    enCodeStr = enCodeStr + coord1 + coord2;\n  }\n\n  return enCodeStr;\n});","map":null,"metadata":{},"sourceType":"module"}