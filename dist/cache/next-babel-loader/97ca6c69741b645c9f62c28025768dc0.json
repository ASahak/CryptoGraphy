{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar Playfair = /*#__PURE__*/function () {\n  function Playfair() {\n    _classCallCheck(this, Playfair);\n  }\n\n  _createClass(Playfair, null, [{\n    key: \"deCodeCipher\",\n    // static isChet = false;\n    // static flag = false;\n    value: function deCodeCipher(msg, key) {\n      var text = '';\n      var text1 = this.doCipher(msg, key);\n      var keyResult = this.processKey(key);\n\n      for (var i = 0; i < text1.length; i += 2) {\n        var pair1 = text1[i];\n        var pair2 = text1[i + 1];\n        var p1i = void 0,\n            p1j = void 0,\n            p2i = void 0,\n            p2j = void 0;\n\n        for (var stroke = 0; stroke < keyResult.length; stroke++) {\n          for (var stolbec = 0; stolbec < keyResult[stroke].length; stolbec++) {\n            if (keyResult[stroke][stolbec] === pair1) {\n              p1i = stroke;\n              p1j = stolbec;\n            }\n\n            if (keyResult[stroke][stolbec] === pair2) {\n              p2i = stroke;\n              p2j = stolbec;\n            }\n          }\n        }\n\n        var coord1 = '',\n            coord2 = '';\n\n        if (p1i === p2i) {\n          if (p1j === 0) {\n            coord1 = keyResult[p1i][4];\n          } else {\n            coord1 = keyResult[p1i][p1j - 1];\n          }\n\n          if (p2j === 0) {\n            coord2 = keyResult[p2i][4];\n          } else {\n            coord2 = keyResult[p2i][p2j - 1];\n          }\n        }\n\n        if (p1j === p2j) {\n          if (p1i === 0) {\n            coord1 = keyResult[4][p1j];\n          } else {\n            coord1 = keyResult[p1i - 1][p1j];\n          }\n\n          if (p2i === 0) {\n            coord2 = keyResult[4][p2j];\n          } else {\n            coord2 = keyResult[p2i - 1][p2j];\n          }\n        }\n\n        if (p1i !== p2i && p1j !== p2j) {\n          coord1 = keyResult[p1i][p2j];\n          coord2 = keyResult[p2i][p1j];\n        }\n\n        text = text + coord1 + coord2;\n      }\n\n      text = text.split('');\n\n      for (var _i = 0; _i < text.length; _i++) {\n        var count = void 0;\n\n        if (this.flagAdd) {\n          if (text[_i] === text[_i + 2] && (text[_i + 1] === 'X' || text[_i + 1] === 'Q')) {\n            count = _i + 1;\n            text.splice(count, 1);\n          }\n        } else if (this.flagAdd && this.isEnd && (this.flagX || !this.flagX)) {\n          if (text[_i - 2] === text[_i] && (text[_i - 1] === 'X' || text[_i - 1] === 'Q')) count = _i + 1;\n          text.splice(count, 1);\n        } else if (!this.flagAdd) {\n          break;\n        }\n      }\n\n      if (this.flagX) {\n        text.pop();\n      }\n\n      if (this.isEnd && !this.flagX) {\n        text.pop();\n      }\n\n      text = text.join('');\n      return text;\n    }\n  }, {\n    key: \"processKey\",\n    value: function processKey(key) {\n      var _key = key;\n      _key = _key.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\n      var temp = '';\n      var alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ';\n\n      for (var i = 0; i < _key.length; i++) {\n        if (alphabet.indexOf(_key[i]) !== -1) {\n          alphabet = alphabet.replace(_key[i], '');\n          temp += _key[i];\n        }\n      }\n\n      temp += alphabet;\n      var result = [];\n      temp = temp.split('');\n\n      while (temp[0]) {\n        result.push(temp.splice(0, 5));\n      }\n\n      return result;\n    }\n  }]);\n\n  return Playfair;\n}();\n\n_defineProperty(Playfair, \"flagX\", false);\n\n_defineProperty(Playfair, \"flagAdd\", false);\n\n_defineProperty(Playfair, \"isEnd\", false);\n\n_defineProperty(Playfair, \"doCipher\", function (msg, key, callback) {\n  var keyResult = Playfair.processKey(key);\n  var error = 'Warning!!! String is empty';\n  var textPhrase, separator;\n  msg = msg.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\n\n  if (msg.length === 0) {\n    callback(error);\n    return;\n  } else {\n    textPhrase = msg[0];\n  }\n\n  var help = 0;\n\n  for (var i = 1; i < msg.length; i++) {\n    if (msg[i - 1] === msg[i]) {\n      if (msg[i] === 'X') {\n        separator = 'Q';\n      } else {\n        separator = 'X';\n      }\n\n      textPhrase += separator + msg[i];\n      help = 1;\n    } else {\n      textPhrase += msg[i];\n    }\n\n    if (help === 1) {\n      Playfair.flagAdd = true;\n    }\n  }\n\n  if (textPhrase.length % 2 !== 0) {\n    if (textPhrase[textPhrase.length - 1] === 'X') {\n      textPhrase += 'Q';\n      Playfair.isEnd = true;\n      Playfair.flagX = false;\n    } else {\n      textPhrase += 'X';\n      Playfair.isEnd = true;\n      Playfair.flagX = true;\n    }\n  }\n\n  var enCodeStr = '';\n\n  for (var _i2 = 0; _i2 < textPhrase.length; _i2 += 2) {\n    var pair1 = textPhrase[_i2];\n    var pair2 = textPhrase[_i2 + 1];\n    var p1i = void 0,\n        p1j = void 0,\n        p2i = void 0,\n        p2j = void 0;\n\n    for (var stroke = 0; stroke < keyResult.length; stroke++) {\n      for (var stolbec = 0; stolbec < keyResult[stroke].length; stolbec++) {\n        if (keyResult[stroke][stolbec] === pair1) {\n          p1i = stroke;\n          p1j = stolbec;\n        }\n\n        if (keyResult[stroke][stolbec] === pair2) {\n          p2i = stroke;\n          p2j = stolbec;\n        }\n      }\n    }\n\n    var coord1 = '',\n        coord2 = '';\n\n    if (p1i === p2i) {\n      if (p1j === 4) {\n        coord1 = keyResult[p1i][0];\n      } else {\n        coord1 = keyResult[p1i][p1j + 1];\n      }\n\n      if (p2j === 4) {\n        coord2 = keyResult[p2i][0];\n      } else {\n        coord2 = keyResult[p2i][p2j + 1];\n      }\n    }\n\n    if (p1j === p2j) {\n      if (p1i === 4) {\n        coord1 = keyResult[0][p1j];\n      } else {\n        coord1 = keyResult[p1i + 1][p1j];\n      }\n\n      if (p2i === 4) {\n        coord2 = keyResult[0][p2j];\n      } else {\n        coord2 = keyResult[p2i + 1][p2j];\n      }\n    }\n\n    if (p1i !== p2i && p1j !== p2j) {\n      coord1 = keyResult[p1i][p2j];\n      coord2 = keyResult[p2i][p1j];\n    }\n\n    enCodeStr = enCodeStr + coord1 + coord2;\n  }\n\n  return enCodeStr;\n});\n\nexport { Playfair as default };","map":{"version":3,"sources":["C:/Users/ruala/Desktop/ASahak/daser/next/CryptoGraphy/libraries/Playfair.js"],"names":["Playfair","msg","key","text","text1","doCipher","keyResult","processKey","i","length","pair1","pair2","p1i","p1j","p2i","p2j","stroke","stolbec","coord1","coord2","split","count","flagAdd","splice","isEnd","flagX","pop","join","_key","toUpperCase","replace","temp","alphabet","indexOf","result","push","callback","error","textPhrase","separator","help","enCodeStr"],"mappings":"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","sourcesContent":["export default class Playfair {\r\n    // static isChet = false;\r\n    // static flag = false;\r\n    static flagX = false;\r\n    static flagAdd = false;\r\n    static isEnd = false;\r\n\r\n    static doCipher = (msg, key, callback) => {\r\n        let keyResult = this.processKey(key);\r\n        let error = 'Warning!!! String is empty';\r\n\r\n        let textPhrase, separator;\r\n        msg = msg.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\r\n        if(msg.length === 0) {\r\n            callback(error);\r\n            return;\r\n        } else {\r\n            textPhrase = msg[0];\r\n        }\r\n        let help = 0;\r\n        for(let i = 1; i < msg.length; i++) {\r\n            if(msg[i - 1] === msg[i]) {\r\n                if(msg[i] === 'X') {\r\n                    separator = 'Q';\r\n                }\r\n                else {\r\n                    separator = 'X';\r\n                }\r\n                textPhrase += separator + msg[i];\r\n                help = 1;\r\n            }\r\n            else {\r\n                textPhrase += msg[i];\r\n            }\r\n            if(help === 1) {\r\n                this.flagAdd = true;\r\n            }\r\n        }\r\n\r\n        if(textPhrase.length % 2 !== 0) {\r\n            if(textPhrase[textPhrase.length - 1] === 'X') {\r\n                textPhrase += 'Q';\r\n                this.isEnd = true;\r\n                this.flagX = false;\r\n            }\r\n            else {\r\n                textPhrase += 'X';\r\n                this.isEnd = true;\r\n                this.flagX = true;\r\n            }\r\n        }\r\n\r\n        let enCodeStr = '';\r\n        for(let i = 0; i < textPhrase.length; i += 2){\r\n            let pair1 = textPhrase[i];\r\n            let pair2 = textPhrase[i + 1];\r\n            let p1i, p1j, p2i, p2j;\r\n            for(let stroke = 0; stroke < keyResult.length; stroke++) {\r\n                for(let stolbec = 0; stolbec < keyResult[stroke].length; stolbec++){\r\n                    if (keyResult[stroke][stolbec] === pair1){\r\n                        p1i = stroke;\r\n                        p1j = stolbec;\r\n                    }\r\n                    if (keyResult[stroke][stolbec] === pair2){\r\n                        p2i = stroke;\r\n                        p2j = stolbec;\r\n                    }\r\n                }\r\n            }\r\n            let coord1 = '', coord2 = '';\r\n\r\n            if(p1i === p2i) {\r\n                if(p1j === 4) {\r\n                    coord1 = keyResult[p1i][0];\r\n                }\r\n                else {\r\n                    coord1 = keyResult[p1i][p1j + 1];\r\n                }\r\n                if(p2j === 4) {\r\n                    coord2 = keyResult[p2i][0];\r\n                }\r\n                else {\r\n                    coord2 = keyResult[p2i][p2j + 1]\r\n                }\r\n            }\r\n            if(p1j === p2j) {\r\n                if(p1i === 4) {\r\n                    coord1 = keyResult[0][p1j];\r\n                }\r\n                else {\r\n                    coord1 = keyResult[p1i + 1][p1j];\r\n                }\r\n                if(p2i === 4) {\r\n                    coord2 = keyResult[0][p2j];\r\n                }\r\n                else {\r\n                    coord2 = keyResult[p2i + 1][p2j]\r\n                }\r\n            }\r\n            if(p1i !== p2i && p1j !== p2j) {\r\n                coord1 = keyResult[p1i][p2j];\r\n                coord2 = keyResult[p2i][p1j];\r\n            }\r\n            enCodeStr = enCodeStr + coord1 + coord2;\r\n        }\r\n        return enCodeStr;\r\n    }\r\n\r\n    static deCodeCipher (msg, key) {\r\n        let text = '';\r\n        let text1 = this.doCipher(msg, key);\r\n        let keyResult = this.processKey(key);\r\n        for(let i = 0; i < text1.length; i += 2){\r\n            let pair1 = text1[i];\r\n            let pair2 = text1[i + 1];\r\n            let p1i, p1j, p2i, p2j;\r\n            for(let stroke = 0; stroke < keyResult.length; stroke++) {\r\n                for(let stolbec = 0; stolbec < keyResult[stroke].length; stolbec++){\r\n                    if (keyResult[stroke][stolbec] === pair1){\r\n                        p1i = stroke;\r\n                        p1j = stolbec;\r\n                    }\r\n                    if (keyResult[stroke][stolbec] === pair2){\r\n                        p2i = stroke;\r\n                        p2j = stolbec;\r\n                    }\r\n                }\r\n            }\r\n            let coord1 = '', coord2 = '';\r\n\r\n            if(p1i === p2i) {\r\n                if(p1j === 0) {\r\n                    coord1 = keyResult[p1i][4];\r\n                }\r\n                else {\r\n                    coord1 = keyResult[p1i][p1j - 1];\r\n                }\r\n                if(p2j === 0) {\r\n                    coord2 = keyResult[p2i][4];\r\n                }\r\n                else {\r\n                    coord2 = keyResult[p2i][p2j - 1]\r\n                }\r\n            }\r\n            if(p1j === p2j) {\r\n                if(p1i === 0) {\r\n                    coord1 = keyResult[4][p1j]\r\n                }\r\n                else {\r\n                    coord1 = keyResult[p1i - 1][p1j];\r\n                }\r\n                if(p2i === 0) {\r\n                    coord2 = keyResult[4][p2j];\r\n                }\r\n                else {\r\n                    coord2 = keyResult[p2i - 1][p2j]\r\n                }\r\n            }\r\n            if(p1i !== p2i && p1j !== p2j) {\r\n                coord1 = keyResult[p1i][p2j];\r\n                coord2 = keyResult[p2i][p1j];\r\n            }\r\n            text = text + coord1 + coord2;\r\n        }\r\n        text = text.split('');\r\n\r\n        for(let i = 0; i < text.length; i++) {\r\n            let count;\r\n            if (this.flagAdd) {\r\n                if(text[i] === text[i + 2] && (text[i + 1] === 'X' || text[i + 1] === 'Q')) {\r\n                    count = i + 1;\r\n                    text.splice(count, 1);\r\n                }\r\n            }\r\n            else if(this.flagAdd && this.isEnd && (this.flagX || !this.flagX)) {\r\n                if(text[i - 2] === text[i] && (text[i - 1] === 'X' || text[i - 1] === 'Q'))\r\n                    count = i + 1;\r\n                text.splice(count, 1);\r\n            }\r\n            else if(!this.flagAdd) {\r\n                break;\r\n            }\r\n        }\r\n        if(this.flagX) {\r\n            text.pop();\r\n        }\r\n        if(this.isEnd && !this.flagX) {\r\n            text.pop();\r\n        }\r\n        text = text.join('');\r\n        return text;\r\n    }\r\n\r\n    static processKey (key) {\r\n        let _key = key;\r\n        _key = _key.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\r\n        let temp = '';\r\n        let alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ';\r\n        for(let i = 0; i < _key.length; i++) {\r\n            if (alphabet.indexOf(_key[i]) !== -1) {\r\n                alphabet = alphabet.replace(_key[i], '');\r\n                temp += _key[i];\r\n            }\r\n        }\r\n        temp += alphabet;\r\n        const result = [];\r\n        temp = temp.split('');\r\n        while(temp[0]) {\r\n            result.push(temp.splice(0,5));\r\n        }\r\n        return result;\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}