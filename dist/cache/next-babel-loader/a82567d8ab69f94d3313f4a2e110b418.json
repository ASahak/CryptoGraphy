{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar Playfair = /*#__PURE__*/function () {\n  function Playfair() {\n    _classCallCheck(this, Playfair);\n  }\n\n  _createClass(Playfair, null, [{\n    key: \"deCodeCipher\",\n    // static isChet = false;\n    // static flag = false;\n    value: function deCodeCipher(msg, key) {\n      var text = '';\n      var text1 = this.doCipher(msg, key);\n      var keyResult = this.processKey(key);\n\n      for (var i = 0; i < text1.length; i += 2) {\n        var pair1 = text1[i];\n        var pair2 = text1[i + 1];\n        var p1i = void 0,\n            p1j = void 0,\n            p2i = void 0,\n            p2j = void 0;\n\n        for (var stroke = 0; stroke < keyResult.length; stroke++) {\n          for (var stolbec = 0; stolbec < keyResult[stroke].length; stolbec++) {\n            if (keyResult[stroke][stolbec] === pair1) {\n              p1i = stroke;\n              p1j = stolbec;\n            }\n\n            if (keyResult[stroke][stolbec] === pair2) {\n              p2i = stroke;\n              p2j = stolbec;\n            }\n          }\n        }\n\n        var coord1 = '',\n            coord2 = '';\n\n        if (p1i === p2i) {\n          if (p1j === 0) {\n            coord1 = keyResult[p1i][4];\n          } else {\n            coord1 = keyResult[p1i][p1j - 1];\n          }\n\n          if (p2j === 0) {\n            coord2 = keyResult[p2i][4];\n          } else {\n            coord2 = keyResult[p2i][p2j - 1];\n          }\n        }\n\n        if (p1j === p2j) {\n          if (p1i === 0) {\n            coord1 = keyResult[4][p1j];\n          } else {\n            coord1 = keyResult[p1i - 1][p1j];\n          }\n\n          if (p2i === 0) {\n            coord2 = keyResult[4][p2j];\n          } else {\n            coord2 = keyResult[p2i - 1][p2j];\n          }\n        }\n\n        if (p1i !== p2i && p1j !== p2j) {\n          coord1 = keyResult[p1i][p2j];\n          coord2 = keyResult[p2i][p1j];\n        }\n\n        text = text + coord1 + coord2;\n      }\n\n      text = text.split('');\n\n      for (var _i = 0; _i < text.length; _i++) {\n        var count = void 0;\n\n        if (this.flagAdd) {\n          if (text[_i] === text[_i + 2] && (text[_i + 1] === 'X' || text[_i + 1] === 'Q')) {\n            count = _i + 1;\n            text.splice(count, 1);\n          }\n        } else if (this.flagAdd && this.isEnd && (this.flagX || !this.flagX)) {\n          if (text[_i - 2] === text[_i] && (text[_i - 1] === 'X' || text[_i - 1] === 'Q')) count = _i + 1;\n          text.splice(count, 1);\n        } else if (!this.flagAdd) {\n          break;\n        }\n      }\n\n      if (this.flagX) {\n        text.pop();\n      }\n\n      if (this.isEnd && !this.flagX) {\n        text.pop();\n      }\n\n      text = text.join('');\n      return text;\n    }\n  }, {\n    key: \"processKey\",\n    value: function processKey(key) {\n      var _key = key;\n      _key = _key.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\n      var temp = '';\n      var alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ';\n\n      for (var i = 0; i < _key.length; i++) {\n        if (alphabet.indexOf(_key[i]) !== -1) {\n          alphabet = alphabet.replace(_key[i], '');\n          temp += _key[i];\n        }\n      }\n\n      temp += alphabet;\n      var result = [];\n      temp = temp.split('');\n\n      while (temp[0]) {\n        result.push(temp.splice(0, 5));\n      }\n\n      return result;\n    }\n  }]);\n\n  return Playfair;\n}();\n\n_defineProperty(Playfair, \"flagX\", false);\n\n_defineProperty(Playfair, \"flagAdd\", false);\n\n_defineProperty(Playfair, \"isEnd\", false);\n\n_defineProperty(Playfair, \"doCipher\", function (msg, key, callback) {\n  var keyResult = Playfair.processKey(key);\n  var error = 'Warning!!! String is empty';\n  var textPhrase, separator;\n  msg = msg.toUpperCase().replace(/\\s/g, '').replace(/J/g, \"I\");\n\n  if (msg.length === 0) {\n    callback(error);\n    return;\n  } else {\n    textPhrase = msg[0];\n  }\n\n  var help = 0;\n\n  for (var i = 1; i < msg.length; i++) {\n    if (msg[i - 1] === msg[i]) {\n      if (msg[i] === 'X') {\n        separator = 'Q';\n      } else {\n        separator = 'X';\n      }\n\n      textPhrase += separator + msg[i];\n      help = 1;\n    } else {\n      textPhrase += msg[i];\n    }\n\n    if (help === 1) {\n      Playfair.flagAdd = true;\n    }\n  }\n\n  if (textPhrase.length % 2 !== 0) {\n    if (textPhrase[textPhrase.length - 1] === 'X') {\n      textPhrase += 'Q';\n      Playfair.isEnd = true;\n      Playfair.flagX = false;\n    } else {\n      textPhrase += 'X';\n      Playfair.isEnd = true;\n      Playfair.flagX = true;\n    }\n  }\n\n  var enCodeStr = '';\n\n  for (var _i2 = 0; _i2 < textPhrase.length; _i2 += 2) {\n    var pair1 = textPhrase[_i2];\n    var pair2 = textPhrase[_i2 + 1];\n    var p1i = void 0,\n        p1j = void 0,\n        p2i = void 0,\n        p2j = void 0;\n\n    for (var stroke = 0; stroke < keyResult.length; stroke++) {\n      for (var stolbec = 0; stolbec < keyResult[stroke].length; stolbec++) {\n        if (keyResult[stroke][stolbec] === pair1) {\n          p1i = stroke;\n          p1j = stolbec;\n        }\n\n        if (keyResult[stroke][stolbec] === pair2) {\n          p2i = stroke;\n          p2j = stolbec;\n        }\n      }\n    }\n\n    var coord1 = '',\n        coord2 = '';\n\n    if (p1i === p2i) {\n      if (p1j === 4) {\n        coord1 = keyResult[p1i][0];\n      } else {\n        coord1 = keyResult[p1i][p1j + 1];\n      }\n\n      if (p2j === 4) {\n        coord2 = keyResult[p2i][0];\n      } else {\n        coord2 = keyResult[p2i][p2j + 1];\n      }\n    }\n\n    if (p1j === p2j) {\n      if (p1i === 4) {\n        coord1 = keyResult[0][p1j];\n      } else {\n        coord1 = keyResult[p1i + 1][p1j];\n      }\n\n      if (p2i === 4) {\n        coord2 = keyResult[0][p2j];\n      } else {\n        coord2 = keyResult[p2i + 1][p2j];\n      }\n    }\n\n    if (p1i !== p2i && p1j !== p2j) {\n      coord1 = keyResult[p1i][p2j];\n      coord2 = keyResult[p2i][p1j];\n    }\n\n    enCodeStr = enCodeStr + coord1 + coord2;\n  }\n\n  return enCodeStr;\n});\n\nexport { Playfair as default };","map":null,"metadata":{},"sourceType":"module"}