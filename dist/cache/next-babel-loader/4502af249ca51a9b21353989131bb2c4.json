{"ast":null,"code":"import { useState, useEffect } from 'react';\nexport function useDebounce(value, delay) {\n  // State and setters for debounced value\n  const {\n    0: debouncedValue,\n    1: setDebouncedValue\n  } = useState(value);\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay] // Only re-call effect if value or delay changes\n  );\n  return debouncedValue;\n}\nexport function classDebounce(func, wait, immediate) {\n  let timeout;\n  return function () {\n    let context = this,\n        args = arguments;\n\n    const later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}","map":{"version":3,"sources":["C:/Users/ruala/Desktop/ASahak/daser/next/CryptoGraphy/hooks/use-debounce.jsx"],"names":["useState","useEffect","useDebounce","value","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","classDebounce","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAmC,OAAnC;AAEA,OAAO,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmC;AACtC;AACA,QAAM;AAAA,OAACC,cAAD;AAAA,OAAiBC;AAAjB,MAAsCN,QAAQ,CAACG,KAAD,CAApD;AAEAF,EAAAA,SAAS,CACL,MAAM;AACF;AACA,UAAMM,OAAO,GAAGC,UAAU,CAAC,MAAM;AAC7BF,MAAAA,iBAAiB,CAACH,KAAD,CAAjB;AACH,KAFyB,EAEvBC,KAFuB,CAA1B,CAFE,CAMF;AACA;AACA;;AACA,WAAO,MAAM;AACTK,MAAAA,YAAY,CAACF,OAAD,CAAZ;AACH,KAFD;AAGH,GAbI,EAcL,CAACJ,KAAD,EAAQC,KAAR,CAdK,CAcU;AAdV,GAAT;AAiBA,SAAOC,cAAP;AACH;AAGD,OAAO,SAASK,aAAT,CAAwBC,IAAxB,EAA8BC,IAA9B,EAAoCC,SAApC,EAA+C;AAClD,MAAIC,OAAJ;AACA,SAAO,YAAW;AACd,QAAIC,OAAO,GAAG,IAAd;AAAA,QAAoBC,IAAI,GAAGC,SAA3B;;AACA,UAAMC,KAAK,GAAG,YAAW;AACrBJ,MAAAA,OAAO,GAAG,IAAV;AACA,UAAI,CAACD,SAAL,EAAgBF,IAAI,CAACQ,KAAL,CAAWJ,OAAX,EAAoBC,IAApB;AACnB,KAHD;;AAIA,UAAMI,OAAO,GAAGP,SAAS,IAAI,CAACC,OAA9B;AACAL,IAAAA,YAAY,CAACK,OAAD,CAAZ;AACAA,IAAAA,OAAO,GAAGN,UAAU,CAACU,KAAD,EAAQN,IAAR,CAApB;AACA,QAAIQ,OAAJ,EAAaT,IAAI,CAACQ,KAAL,CAAWJ,OAAX,EAAoBC,IAApB;AAChB,GAVD;AAWH","sourcesContent":["import { useState, useEffect} from 'react';\r\n\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n\r\n    useEffect(\r\n        () => {\r\n            // Update debounced value after delay\r\n            const handler = setTimeout(() => {\r\n                setDebouncedValue(value);\r\n            }, delay);\r\n\r\n            // Cancel the timeout if value changes (also on delay change or unmount)\r\n            // This is how we prevent debounced value from updating if value is changed ...\r\n            // .. within the delay period. Timeout gets cleared and restarted.\r\n            return () => {\r\n                clearTimeout(handler);\r\n            };\r\n        },\r\n        [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n\r\n    return debouncedValue;\r\n}\r\n\r\n\r\nexport function classDebounce (func, wait, immediate) {\r\n    let timeout;\r\n    return function() {\r\n        let context = this, args = arguments;\r\n        const later = function() {\r\n            timeout = null;\r\n            if (!immediate) func.apply(context, args);\r\n        };\r\n        const callNow = immediate && !timeout;\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n        if (callNow) func.apply(context, args);\r\n    };\r\n}"]},"metadata":{},"sourceType":"module"}